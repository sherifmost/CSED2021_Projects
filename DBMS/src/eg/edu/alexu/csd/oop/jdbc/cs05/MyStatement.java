package eg.edu.alexu.csd.oop.jdbc.cs05;

import java.sql.BatchUpdateException;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.util.ArrayList;
import java.util.LinkedList;

import eg.edu.alexu.csd.oop.db.Database;

/*The object used for executing a static SQL statement and returning the results it produces.
 
By default, only one ResultSet object per Statement object can be open at the same time.//////// 
Therefore, if the reading of one ResultSet object is interleaved with the reading of another, 
each must have been generated by different Statement objects.
 All execution methods in the Statement interface implicitly 
 close a current ResultSet object of the statement if an open one exists.*/
//only one ResultSet at a time.
public class MyStatement implements java.sql.Statement {
	private Database db;
	private Connection connection;
	private boolean closed = false;// if this statement is closed.
	private int timeOut = 0;// time till statement execution timeout, 0 means has no limit.
	private LinkedList<String> commands = new LinkedList<>();// a list of all the commands in this statement object.
	private ArrayList<Integer> status = new ArrayList<>();// has the status of each query either update count,
															// successful process or error.
	private int error = -1;// error status means operation failed.
	private int success = -2;// success with no count indicator.
	private int selected = -3;// select operation unhandled in batch.

	public MyStatement(Database database, Connection connection) {
		setDb(database);
		this.connection = connection;
	}

	public Database getDb() {
		return db;
	}

	public void setDb(Database db) {
		this.db = db;
	}

	@Override
	public void setQueryTimeout(int seconds) throws SQLException {// Sets the number of seconds the driver will wait for
																	// a Statement object
																	// to execute to the given number of seconds.
																	// A JDBC driver must apply this limit to the
																	// execute,
																	// executeQuery and executeUpdate methods.
		if (seconds < 0 || closed) {
			throw new SQLException();
		}
		timeOut = seconds;
	}

	@Override
	public int getQueryTimeout() throws SQLException {// Retrieves the number of seconds the driver will wait for a
														// Statement object to execute.
														// If the limit is exceeded, a SQLException is thrown.
		if (closed) {
			throw new SQLException();
		}
		return timeOut;
	}

	@Override
	public void addBatch(String sql) throws SQLException {// add new command
		if (closed) {
			throw new SQLException();
		}
		commands.add(sql);
	}

	@Override
	public void clearBatch() throws SQLException {// clear all the commands
		if (closed) {
			throw new SQLException();
		}
		commands.clear();
	}

	@Override
	public boolean execute(String sql) throws SQLException {// executes the given SQL statement returns true only if the
															// statement
															// was made and may return other multiple results
															// true if the first result is a ResultSet object or a
															// structured query;
															// false if it is an update count
		if (closed) {
			throw new SQLException();
		}
		try {
			boolean returned = db.executeStructureQuery(sql);
			if (returned)
				status.add(success);
			else
				status.add(error);
			return returned;
		} catch (Exception eret1) {
			try {
				status.add(this.executeUpdate(sql));
				return true;
			} catch (Exception e2) {
				try {
					if (this.executeQuery(sql) == null) {
						status.add(error);
						return false;
					}
					status.add(selected);// a result set was tried to be returned(can't return it in the execute batch
											// array).
					return true;
				} catch (Exception e3) {
					System.out.println("INVALID QUERY");

					throw new BatchUpdateException();// if driver wishes to continue neglect this exception
				}
			}

		}
	}

	@Override
	public void close()
			throws SQLException {/*
									 * Releases this Statement object's database and JDBC resources immediately
									 * instead of waiting for this to happen when it is automatically closed.
									 */
		this.setQueryTimeout(0);
		closed = true;
		db = null;
		this.connection = null;// not
								// sure---------------------------------------------------------------------------
		status = null;// not
						// sure-------------------------------------------------------------------------------
		commands = null;
	}

	@Override
	public int[] executeBatch() throws SQLException {// Submits a batch of commands to the database for execution
														// and if all commands execute successfully, returns an array of
														// update counts.
														// the methods returning integer counts are those who perform
														// update operations.
														// throws BatchUpdateException if query returns a result set.
		status.clear();
		int i;
		int length = commands.size();
		for (i = 0; i < length; i++) {
			execute(commands.get(i));//stops if wrong query was added.
		}

		return get_array(status);
	}

	private int[] get_array(ArrayList<Integer> status) {// returns the given list as an array.
		int[] temp = new int[status.size()];
		int i;
		int length = temp.length;
		for (i = 0; i < length; i++) {
			temp[i] = status.get(i);
		}
		return temp;
	}

	@Override
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public ResultSet executeQuery(String sql) throws SQLException {// Executes the given SQL statement,
																	// which returns a single ResultSet object.

		if (closed) {
			throw new SQLException();
		}
		Object[][] returned = db.executeQuery(sql);// null problem to be checked
		if (returned.length == 0) {
			return null;
		}
		return new MyResultSet(returned, db, this);// returns a NEWWWWW result set having a 2d array of the selected
													// data.
	}

	@Override
	public int executeUpdate(String sql) throws SQLException {// Executes the given SQL statement, which may be an
																// INSERT, UPDATE,
																// or DELETE statement or an SQL statement that returns
																// nothing,
																// such as an SQL DDL statement.

		if (closed) {
			throw new SQLException();
		}
		return db.executeUpdateQuery(sql);// execute the update query and return the update count.
	}

	@Override
	public Connection getConnection() throws SQLException {// Retrieves the Connection object that produced this
															// Statement object.
		if (closed) {
			throw new SQLException();
		}

		return this.connection;
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public void cancel() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public void clearWarnings() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public void closeOnCompletion() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public int getFetchDirection() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public int getFetchSize() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public int getMaxRows() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public int getResultSetType() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public int getUpdateCount() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public boolean isCloseOnCompletion() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public boolean isClosed() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public boolean isPoolable() throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public void setCursorName(String name) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public void setMaxRows(int max) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
		throw new java.lang.UnsupportedOperationException();
	}

}